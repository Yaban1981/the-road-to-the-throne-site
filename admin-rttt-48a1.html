<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>QHC — Admin Lineups 2026</title>
  <meta name="description" content="Admin mobile-first pour gérer les lineups QHC par année et tournoi (Boston, Meltdown, Jay Peak, The Throne) avec sauvegarde GitHub." />
  <link rel="icon" href="logos/qhc.png" />
  <meta name="theme-color" content="#020617" />

  <style>
    :root{
      --bg:#020617;
      --panel:#020617;
      --panel2:#030712;
      --text:#e5e7eb;
      --muted:#9ca3af;
      --accent:#fbbf24;
      --accent2:#3b82f6;
      --danger:#ef4444;
      --ok:#22c55e;
      --ring:rgba(59,130,246,.35);
      --radius:16px;
    }
    *{box-sizing:border-box;-webkit-tap-highlight-color:transparent}
    html,body{scroll-behavior:smooth;-webkit-text-size-adjust:100%}
    body{
      margin:0;
      font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Helvetica,Arial,sans-serif;
      background:radial-gradient(900px 500px at 10% -10%,#0b2451 0%,transparent 60%),linear-gradient(180deg,#020617,#020617);
      color:var(--text);
      line-height:1.5;
    }

    /* Header mobile-first */
    header{
      padding:16px 12px 10px;
      border-bottom:1px solid rgba(148,163,184,.25);
      background:radial-gradient(600px 260px at 10% -20%,rgba(59,130,246,.24),transparent 60%),
                 linear-gradient(180deg,#020617,#030712);
    }
    .header-inner{
      max-width:800px;
      margin:0 auto;
      display:flex;
      align-items:center;
      gap:12px;
    }
    .header-logo{
      width:56px;height:56px;border-radius:18px;
      overflow:hidden;display:grid;place-items:center;
      background:#020617;
      box-shadow:0 10px 26px rgba(0,0,0,.55);
      flex-shrink:0;
    }
    .header-logo img{width:100%;height:100%;object-fit:cover}
    .header-text{display:flex;flex-direction:column;gap:2px}
    .header-text h1{
      margin:0;
      font-size:1.2rem;
      letter-spacing:.03em;
    }
    .header-sub{
      font-size:.85rem;
      color:#cbd5f5;
    }
    .header-meta{
      font-size:.75rem;
      color:#9ca3af;
    }

    main{
      max-width:900px;
      margin:0 auto;
      padding:10px 10px 40px;
    }

    .card{
      background:radial-gradient(300px 200px at 0% -20%,rgba(59,130,246,.18),transparent 60%),
                 linear-gradient(180deg,var(--panel2),var(--panel));
      border-radius:var(--radius);
      border:1px solid rgba(148,163,184,.35);
      box-shadow:0 10px 30px rgba(0,0,0,.55);
      padding:14px 12px;
      margin:10px 0;
    }

    h2{margin:0 0 8px;font-size:1rem}
    .small-title{font-size:.9rem;color:var(--muted);margin-bottom:6px}

    /* Controls */
    .top-controls{
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    @media(min-width:700px){
      .top-controls{
        flex-direction:row;
        align-items:flex-end;
      }
    }

    label{font-size:.8rem;color:var(--muted);margin-bottom:4px;display:block}

    select,input[type="text"],input[type="password"]{
      width:100%;
      padding:9px 11px;
      border-radius:10px;
      border:1px solid rgba(148,163,184,.55);
      background:#020617;
      color:var(--text);
      font-size:.9rem;
      outline:none;
    }
    select:focus,input:focus{
      border-color:var(--accent2);
      box-shadow:0 0 0 2px var(--ring);
    }

    .btn{
      border:0;
      border-radius:999px;
      padding:8px 14px;
      font-size:.85rem;
      font-weight:600;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      gap:6px;
      cursor:pointer;
      white-space:nowrap;
    }
    .btn-primary{
      background:linear-gradient(135deg,var(--accent),var(--accent2));
      color:#020617;
      box-shadow:0 8px 20px rgba(37,99,235,.45);
    }
    .btn-ghost{
      background:rgba(15,23,42,.7);
      color:var(--text);
      border:1px solid rgba(148,163,184,.5);
    }
    .btn-sm{padding:6px 10px;font-size:.8rem}

    .pill-row{
      display:flex;
      flex-wrap:wrap;
      gap:6px;
    }
    .pill{
      padding:6px 10px;
      border-radius:999px;
      border:1px solid rgba(148,163,184,.5);
      background:#020617;
      color:#e5e7eb;
      font-size:.75rem;
      display:inline-flex;
      align-items:center;
      gap:6px;
      cursor:pointer;
    }
    .pill span.badge{
      padding:2px 6px;
      border-radius:999px;
      font-size:.7rem;
      background:rgba(15,23,42,.85);
      border:1px solid rgba(148,163,184,.8);
    }
    .pill[aria-pressed="true"]{
      border-color:var(--accent);
      background:rgba(234,179,8,.15);
      box-shadow:0 0 0 1px rgba(248,250,252,.05);
    }

    .section-label{
      font-size:.8rem;
      color:var(--muted);
      margin-bottom:4px;
    }

    /* Layout: players + lineup */
    .split{
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    @media(min-width:800px){
      .split{
        flex-direction:row;
        align-items:flex-start;
      }
      .split-left{flex:1.05}
      .split-right{flex:0.95}
    }

    /* Player list */
    .players-toolbar{
      display:flex;
      gap:6px;
      flex-wrap:wrap;
      align-items:center;
      margin-bottom:6px;
    }
    .players-toolbar input[type="text"]{
      flex:1 1 130px;
      min-width:0;
    }
    .checkbox-inline{
      display:inline-flex;
      align-items:center;
      gap:4px;
      font-size:.75rem;
      color:var(--muted);
    }

    .players-list{
      max-height:420px;
      overflow:auto;
      padding-right:4px;
    }
    .player-card{
      border-radius:12px;
      border:1px solid rgba(55,65,81,.9);
      background:rgba(15,23,42,.95);
      padding:8px 9px;
      margin-bottom:6px;
      display:flex;
      flex-direction:column;
      gap:4px;
      position:relative;
    }
    .player-header{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:8px;
    }
    .player-name{
      font-size:.9rem;
      font-weight:600;
    }
    .player-meta{
      font-size:.7rem;
      color:var(--muted);
    }
    .tag-row{
      display:flex;
      flex-wrap:wrap;
      gap:4px;
      margin-top:2px;
    }
    .tag{
      padding:1px 6px;
      border-radius:999px;
      font-size:.7rem;
      border:1px solid rgba(75,85,99,.9);
      background:rgba(15,23,42,.9);
    }
    .tag-pos{border-color:rgba(56,189,248,.9);color:#e0f2fe}
    .tag-side{border-color:rgba(74,222,128,.9);color:#bbf7d0}
    .tag-jersey{border-color:rgba(250,204,21,.9);color:#fef9c3}
    .tag-conf-ok{border-color:rgba(52,211,153,.9);color:#bbf7d0}
    .tag-conf-low{border-color:rgba(248,113,113,.9);color:#fee2e2}
    .tag-avail-yes{border-color:rgba(52,211,153,.9);color:#bbf7d0}
    .tag-avail-no{border-color:rgba(248,113,113,.9);color:#fee2e2}
    .tag-avail-tbd{border-color:rgba(251,191,36,.9);color:#fef3c7}

    .confirm-toggle{
      padding:3px 7px;
      border-radius:999px;
      border:1px solid rgba(148,163,184,.7);
      font-size:.7rem;
      display:inline-flex;
      align-items:center;
      gap:4px;
      cursor:pointer;
      background:rgba(15,23,42,.9);
    }
    .confirm-toggle.confirmed{
      border-color:var(--accent);
      background:rgba(250,204,21,.2);
      color:#fefce8;
    }

    .player-card.candidate-no{
      opacity:.45;
    }
    .player-card.candidate-yes{
      border-color:rgba(250,204,21,.9);
      box-shadow:0 0 0 1px rgba(250,204,21,.4);
    }

    .player-card .assign-hint{
      font-size:.7rem;
      color:var(--muted);
    }

    /* Lineup board */
    .lineup-board{
      border-radius:12px;
      border:1px solid rgba(75,85,99,.95);
      background:rgba(15,23,42,.95);
      padding:8px 9px;
      display:flex;
      flex-direction:column;
      gap:6px;
    }
    .lineup-row{
      border-radius:9px;
      border:1px solid rgba(55,65,81,.9);
      padding:5px 6px;
      display:flex;
      flex-direction:column;
      gap:4px;
    }
    .lineup-row-header{
      display:flex;
      justify-content:space-between;
      align-items:center;
      font-size:.8rem;
      color:var(--muted);
    }
    .lineup-row-title{font-weight:600;color:#e5e7eb}

    .slot-row{
      display:flex;
      gap:4px;
      margin-top:2px;
    }
    .slot{
      flex:1;
      min-height:32px;
      border-radius:8px;
      border:1px dashed rgba(75,85,99,.9);
      padding:3px 6px;
      font-size:.8rem;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:4px;
      cursor:pointer;
      background:rgba(15,23,42,.9);
    }
    .slot-label-pill{
      font-size:.65rem;
      padding:2px 5px;
      border-radius:999px;
      border:1px solid rgba(75,85,99,.9);
      color:#9ca3af;
    }
    .slot-player{
      flex:1;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      font-size:.8rem;
    }
    .slot-empty{
      font-size:.75rem;
      color:#6b7280;
    }
    .slot-clear{
      font-size:.7rem;
      color:#9ca3af;
      padding:0 2px;
      cursor:pointer;
    }
    .slot.active{
      border-style:solid;
      border-color:var(--accent);
      box-shadow:0 0 0 1px rgba(250,204,21,.4);
      background:rgba(250,204,21,.08);
    }

    .status-bar{
      margin-top:6px;
      font-size:.75rem;
      color:var(--muted);
      display:flex;
      flex-wrap:wrap;
      gap:6px;
      align-items:center;
    }
    .status-pill{
      padding:2px 6px;
      border-radius:999px;
      font-size:.7rem;
      border:1px solid rgba(75,85,99,.9);
    }
    .status-pill.ok{border-color:var(--ok);color:#bbf7d0}
    .status-pill.bad{border-color:var(--danger);color:#fecaca}

    .toast{
      position:fixed;
      left:50%;
      bottom:16px;
      transform:translateX(-50%);
      background:#020617;
      color:#f9fafb;
      padding:8px 11px;
      border-radius:999px;
      font-size:.8rem;
      border:1px solid rgba(148,163,184,.8);
      box-shadow:0 12px 30px rgba(0,0,0,.75);
      opacity:0;
      pointer-events:none;
      transition:.2s;
      z-index:50;
    }
    .toast.show{opacity:1;}

    .hint{
      font-size:.75rem;
      color:var(--muted);
      margin-top:4px;
    }
  </style>
</head>
<body>
<header>
  <div class="header-inner">
    <div class="header-logo">
      <img src="logos/qhc.png" alt="Québec HC">
    </div>
    <div class="header-text">
      <h1>QHC — Admin Lineups</h1>
      <div class="header-sub">Mobile-first • Tournoi × Année • GitHub DB</div>
      <div class="header-meta">Boston • Montreal Meltdown • Jay Peak • The Throne — années 2013–2017</div>
    </div>
  </div>
</header>

<main>
  <!-- FILTRES GLOBALS -->
  <section class="card">
    <h2>1) Contexte : année & tournoi</h2>
    <div class="top-controls">
      <div style="flex:0 0 120px">
        <label for="yearSelect">Année de naissance</label>
        <select id="yearSelect">
          <option value="2014" selected>2014</option>
          <option value="2015">2015</option>
          <option value="2017">2017</option>
          <option value="2013">2013</option>
          <!-- 2016: pas de tournois configurés pour le moment -->
        </select>
      </div>
      <div style="flex:1">
        <div class="section-label">Tournois disponibles pour cette année</div>
        <div class="pill-row" id="tournamentPills"></div>
        <div class="hint" id="yearHint"></div>
      </div>
    </div>
  </section>

  <!-- JOUEURS + LINEUP -->
  <section class="card">
    <h2>2) Joueurs & lineup</h2>
    <div class="split">
      <!-- JOUEURS -->
      <div class="split-left">
        <div class="small-title">Joueurs (depuis <code>data/players.json</code>)</div>
        <div class="players-toolbar">
          <input type="text" id="searchInput" placeholder="Recherche (nom / ville)…">
          <label class="checkbox-inline">
            <input type="checkbox" id="onlyAvailable" checked>
            <span>Dispo tournoi</span>
          </label>
          <button class="btn btn-ghost btn-sm" id="btnLoadPlayers">Charger joueurs</button>
        </div>
        <div class="hint">
          Le slot actif est mis en surbrillance. Tape sur une carte joueur pour l'affecter au slot actif.
        </div>
        <div class="players-list" id="playersList"></div>
      </div>

      <!-- LINEUP -->
      <div class="split-right">
        <div class="small-title">Lineup — <span id="currentContextLabel"></span></div>
        <div class="lineup-board" id="lineupBoard"></div>

        <div style="margin-top:6px;display:flex;gap:6px;flex-wrap:wrap">
          <button class="btn btn-primary btn-sm" id="btnCheckLineup">✔ Vérifier lineup</button>
        </div>
        <div class="status-bar" id="statusBar"></div>
      </div>
    </div>
  </section>

  <!-- GITHUB / PERSISTENCE -->
  <section class="card">
    <h2>3) Sauvegarde GitHub (lineups_YYYY.json)</h2>
    <div class="top-controls">
      <div style="flex:1">
        <label for="ghToken">GitHub PAT (fine-grained, contents: read/write sur ce repo)</label>
        <input type="password" id="ghToken" placeholder="pat_...">
        <div class="hint">
          Utilisé seulement dans cette page, jamais stocké. Lineups : <code>data/lineups_YYYY.json</code>.
        </div>
      </div>
      <div style="flex:0 0 180px;display:flex;flex-direction:column;gap:6px">
        <button class="btn btn-ghost btn-sm" id="btnGhLoad">⬇ GitHub (charger)</button>
        <button class="btn btn-primary btn-sm" id="btnGhSave">⬆ GitHub (sauvegarder)</button>
      </div>
    </div>
  </section>

  <!-- RÉSUMÉ RAPIDE -->
  <section class="card">
    <h2>4) Résumé rapide</h2>
    <pre id="summary" style="font-size:.75rem;white-space:pre-wrap;margin:0"></pre>
  </section>
</main>

<div class="toast" id="toast"></div>

<script>
  // ========== CONFIG (ADAPT IF NEEDED) ==========
  const GH_OWNER = "yaban1981";                   // TODO: adapter si besoin
  const GH_REPO  = "the-road-to-the-throne-site"; // TODO: adapter si besoin
  const GH_LINEUPS_TEMPLATE = "data/lineups_YEAR.json";
  const PLAYERS_PATH = "data/players.json";       // Fichier JSON statique avec tous les joueurs

  // Tournois alignés sur le formulaire public (index.html):
  const TOURNAMENTS = {
    boston: {
      key: "boston",
      label: "Boston — CCM Blue Chip",
      years: [2014, 2015, 2017]
    },
    meltdown: {
      key: "meltdown",
      label: "Montreal Meltdown",
      years: [2014]
    },
    jaypeak: {
      key: "jaypeak",
      label: "Jay Peak — Green Mountain Cup",
      years: [2015]
    },
    throne: {
      key: "throne",
      label: "The Throne — Toronto",
      years: [2013, 2014, 2015, 2017]
    }
  };

  // ========== STATE ==========
  let allPlayers = [];                 // Tous les joueurs de players.json
  let filteredPlayers = [];            // Joueurs filtrés (année + tournoi + recherche)
  let currentYear = 2014;
  let currentTournamentKey = "boston";

  // state per page (année courante)
  let lineups = {};  // { tKey: lineupObject }
  let confirmed = {}; // { tKey: { playerId: true } }

  let ghToken = null;
  let ghLineupsSha = null;

  const toastEl = document.getElementById("toast");

  function toast(msg){
    toastEl.textContent = msg;
    toastEl.classList.add("show");
    setTimeout(() => toastEl.classList.remove("show"), 1600);
  }

  // ========== UTILITIES ==========
  function newEmptyLineup(){
    return {
      G: [],
      D1: { LD: [], RD: [] },
      D2: { LD: [], RD: [] },
      D3: { LD: [], RD: [] },
      F1: { LW: [], C: [], RW: [] },
      F2: { LW: [], C: [], RW: [] },
      F3: { LW: [], C: [], RW: [] }
    };
  }

  function ensureLineup(tKey){
    if (!lineups[tKey]) lineups[tKey] = newEmptyLineup();
    if (!confirmed[tKey]) confirmed[tKey] = {};
  }

  function getTournamentAvailabilityKeys(tKey){
    // support plusieurs noms possibles dans players.json
    switch(tKey){
      case "boston":   return ["boston","boston_showdown"];
      case "meltdown": return ["meltdown","montreal_meltdown"];
      case "jaypeak":  return ["jaypeak","jay_peak"];
      case "throne":   return ["throne","the_throne"];
      default:         return [tKey];
    }
  }

  function getAvailability(p, tKey){
    const keys = getTournamentAvailabilityKeys(tKey);
    for (const k of keys){
      if (p.availability && p.availability[k] != null) return p.availability[k];
    }
    return "";
  }

  function availabilityClass(av){
    const v = (av || "").toUpperCase();
    if (v === "YES" || v === "OUI") return "tag-avail-yes";
    if (v === "NO"  || v === "NON") return "tag-avail-no";
    return "tag-avail-tbd";
  }

  function clone(obj){ return JSON.parse(JSON.stringify(obj)); }

  // ========== UI: YEAR & TOURNAMENT PILL ROW ==========
  const yearSelect = document.getElementById("yearSelect");
  const tournamentPills = document.getElementById("tournamentPills");
  const yearHint = document.getElementById("yearHint");
  const currentContextLabel = document.getElementById("currentContextLabel");

  function setupYearAndTournaments(){
    currentYear = parseInt(yearSelect.value,10);

    // Compute tournaments valid for year
    const validKeys = Object.values(TOURNAMENTS)
      .filter(t => t.years.includes(currentYear))
      .map(t => t.key);

    tournamentPills.innerHTML = "";

    if (validKeys.length === 0){
      yearHint.textContent = "Aucun tournoi configuré pour cette année pour le moment.";
      currentTournamentKey = null;
      renderPlayers();
      renderLineup();
      renderSummary();
      return;
    }

    yearHint.textContent = "";
    if (!validKeys.includes(currentTournamentKey)){
      currentTournamentKey = validKeys[0];
    }

    validKeys.forEach(k => {
      const t = TOURNAMENTS[k];
      const btn = document.createElement("button");
      btn.type = "button";
      btn.className = "pill";
      btn.setAttribute("data-tkey", k);
      if (k === currentTournamentKey) btn.setAttribute("aria-pressed","true");
      btn.innerHTML = `
        <span>${t.label}</span>
        <span class="badge">${t.years.join(" • ")}</span>
      `;
      btn.addEventListener("click", () => {
        currentTournamentKey = k;
        // reset active slot on tournoi change
        activeSlot = null;
        updateTournamentPills();
        renderPlayers();
        renderLineup();
        renderSummary();
      });
      tournamentPills.appendChild(btn);
    });

    updateTournamentPills();
    renderPlayers();
    renderLineup();
    renderSummary();
  }

  function updateTournamentPills(){
    const pills = tournamentPills.querySelectorAll(".pill");
    pills.forEach(p => {
      const k = p.getAttribute("data-tkey");
      if (k === currentTournamentKey) p.setAttribute("aria-pressed","true");
      else p.removeAttribute("aria-pressed");
    });
    if (currentTournamentKey){
      currentContextLabel.textContent = `${currentYear} • ${TOURNAMENTS[currentTournamentKey].label}`;
    }else{
      currentContextLabel.textContent = "";
    }
  }

  yearSelect.addEventListener("change", () => {
    // Reset GH SHA because file changes with year
    ghLineupsSha = null;
    setupYearAndTournaments();
  });

  // ========== LOAD PLAYERS (data/players.json) ==========
  const btnLoadPlayers = document.getElementById("btnLoadPlayers");
  const playersListEl = document.getElementById("playersList");
  const searchInput = document.getElementById("searchInput");
  const onlyAvailableCheckbox = document.getElementById("onlyAvailable");

  btnLoadPlayers.addEventListener("click", async () => {
    try{
      const res = await fetch(PLAYERS_PATH, {cache:"no-store"});
      if (!res.ok){
        toast("Impossible de charger data/players.json");
        return;
      }
      const data = await res.json();
      const arr = Array.isArray(data.players) ? data.players : (Array.isArray(data) ? data : []);
      allPlayers = arr;
      toast(`Joueurs chargés: ${arr.length}`);
      renderPlayers();
      renderSummary();
    }catch(e){
      console.error(e);
      toast("Erreur de chargement des joueurs");
    }
  });

  searchInput.addEventListener("input", () => {
    renderPlayers();
  });
  onlyAvailableCheckbox.addEventListener("change", () => {
    renderPlayers();
  });

  // ========== PLAYER FILTERING / RENDER ==========
  let activeSlot = null; // { tKey, group, role }

  function scoreForSlot(p, tKey, group, role){
    // negative score = non éligible
    const av = (getAvailability(p, tKey) || "").toUpperCase();
    if (av === "NO" || av === "NON") return -999;

    let s = 0;
    const primary = p.positions?.primary?.toUpperCase();
    const secondary = p.positions?.secondary?.toUpperCase();

    const has = (x) => primary === x || secondary === x;

    // base sur la position
    if (role === "G"){
      if (!has("GOL")) return -999;
      s += 6;
    }else if (role === "LD" || role === "RD"){
      if (!has("DEF")) return -999;
      s += 4;
      const needSide = role === "LD" ? "L" : "R";
      if ((p.sides || []).includes(needSide)) s += 2;
    }else if (role === "C"){
      if (!has("CEN")) return -999;
      s += 4;
    }else if (role === "LW" || role === "RW"){
      if (!has("FWD") && !has("CEN")) return -999; // centre accepté à l'aile si besoin
      s += 3;
      const needSide = role === "LW" ? "L" : "R";
      if ((p.sides || []).includes(needSide)) s += 2;
    }

    // disponibilité
    if (av === "YES" || av === "OUI") s += 2;

    // confiance
    const c = parseInt(p.confidence_pct || "0",10);
    if (c >= 90) s += 2;
    else if (c >= 80) s += 1;

    return s;
  }

  function renderPlayers(){
    playersListEl.innerHTML = "";
    if (!currentTournamentKey){
      playersListEl.innerHTML = '<div class="hint">Sélectionne une année avec au moins un tournoi.</div>';
      return;
    }
    if (!allPlayers.length){
      playersListEl.innerHTML = '<div class="hint">Clique sur « Charger joueurs » pour lire <code>data/players.json</code>.</div>';
      return;
    }

    const q = searchInput.value.trim().toLowerCase();
    const onlyAvail = onlyAvailableCheckbox.checked;

    filteredPlayers = allPlayers.filter(p => {
      // filter year
      if (String(p.birth_year) !== String(currentYear)) return false;

      // textual filter
      if (q){
        const name = (p.name || "").toLowerCase();
        const city = (p.city || "").toLowerCase();
        if (!name.includes(q) && !city.includes(q)) return false;
      }

      // availability
      if (onlyAvail){
        const av = (getAvailability(p, currentTournamentKey) || "").toUpperCase();
        if (!(av === "YES" || av === "OUI" || av === "TBD")) return false;
      }

      return true;
    });

    // Sorting
    let listToRender = filteredPlayers.slice();

    if (activeSlot){
      listToRender.sort((a,b) => {
        const sa = scoreForSlot(a, activeSlot.tKey, activeSlot.group, activeSlot.role);
        const sb = scoreForSlot(b, activeSlot.tKey, activeSlot.group, activeSlot.role);
        if (sa !== sb) return sb - sa;
        return (a.name || "").localeCompare(b.name || "");
      });
    }else{
      listToRender.sort((a,b) => (a.name || "").localeCompare(b.name || ""));
    }

    if (!listToRender.length){
      playersListEl.innerHTML = '<div class="hint">Aucun joueur pour ce filtre.</div>';
      return;
    }

    ensureLineup(currentTournamentKey);

    listToRender.forEach(p => {
      const card = document.createElement("div");
      card.className = "player-card";

      // Candidate highlight
      if (activeSlot){
        const sc = scoreForSlot(p, activeSlot.tKey, activeSlot.group, activeSlot.role);
        if (sc < 0) card.classList.add("candidate-no");
        else card.classList.add("candidate-yes");
      }

      const header = document.createElement("div");
      header.className = "player-header";

      const left = document.createElement("div");
      const nameEl = document.createElement("div");
      nameEl.className = "player-name";
      nameEl.textContent = p.name || "(sans nom)";
      const metaEl = document.createElement("div");
      metaEl.className = "player-meta";
      metaEl.textContent = `${p.birth_year || "????"} • ${p.city || "—"}`;
      left.appendChild(nameEl);
      left.appendChild(metaEl);

      const confirmBtn = document.createElement("button");
      confirmBtn.type = "button";
      confirmBtn.className = "confirm-toggle";
      confirmBtn.textContent = "Confirmé";

      if (confirmed[currentTournamentKey] && confirmed[currentTournamentKey][p.id]){
        confirmBtn.classList.add("confirmed");
      }

      confirmBtn.addEventListener("click", (ev) => {
        ev.stopPropagation();
        ensureLineup(currentTournamentKey);
        const map = confirmed[currentTournamentKey];
        if (map[p.id]){
          delete map[p.id];
          confirmBtn.classList.remove("confirmed");
        }else{
          map[p.id] = true;
          confirmBtn.classList.add("confirmed");
        }
        renderSummary();
      });

      header.appendChild(left);
      header.appendChild(confirmBtn);
      card.appendChild(header);

      // tags
      const tags = document.createElement("div");
      tags.className = "tag-row";

      const prim = p.positions?.primary;
      const sec  = p.positions?.secondary;
      if (prim){
        const t = document.createElement("span");
        t.className = "tag tag-pos";
        t.textContent = prim.toUpperCase();
        tags.appendChild(t);
      }
      if (sec && sec.toUpperCase() !== "NONE"){
        const t = document.createElement("span");
        t.className = "tag tag-pos";
        t.textContent = sec.toUpperCase();
        tags.appendChild(t);
      }

      if (Array.isArray(p.sides) && p.sides.length){
        const t = document.createElement("span");
        t.className = "tag tag-side";
        t.textContent = "Side " + p.sides.join("/");
        tags.appendChild(t);
      }

      const prefNumber = p.jersey?.pref_numbers?.[0];
      if (prefNumber){
        const t = document.createElement("span");
        t.className = "tag tag-jersey";
        t.textContent = "#" + prefNumber;
        tags.appendChild(t);
      }

      const c = parseInt(p.confidence_pct || "0",10);
      if (!isNaN(c) && c > 0){
        const t = document.createElement("span");
        t.className = "tag " + (c >= 80 ? "tag-conf-ok" : "tag-conf-low");
        t.textContent = c + "%";
        tags.appendChild(t);
      }

      const av = getAvailability(p, currentTournamentKey);
      if (av){
        const t = document.createElement("span");
        t.className = "tag " + availabilityClass(av);
        t.textContent = "Tournoi: " + av.toUpperCase();
        tags.appendChild(t);
      }

      card.appendChild(tags);

      const hint = document.createElement("div");
      hint.className = "assign-hint";
      if (activeSlot){
        hint.textContent = "Tap pour assigner au slot actif : " +
          activeSlot.group + " " + activeSlot.role + ".";
      }else{
        hint.textContent = "Tap sur un slot à droite pour choisir la position, puis tape sur un joueur.";
      }
      card.appendChild(hint);

      card.addEventListener("click", () => {
        if (!activeSlot){
          toast("Sélectionne d'abord un slot dans la colonne lineup.");
          return;
        }
        assignPlayerToActiveSlot(p.id);
      });

      playersListEl.appendChild(card);
    });
  }

  // ========== LINEUP UI ==========
  const lineupBoardEl = document.getElementById("lineupBoard");
  const statusBarEl = document.getElementById("statusBar");
  const btnCheckLineup = document.getElementById("btnCheckLineup");

  function renderLineup(){
    lineupBoardEl.innerHTML = "";

    if (!currentTournamentKey){
      lineupBoardEl.innerHTML = '<div class="hint">Aucun tournoi sélectionné.</div>';
      statusBarEl.innerHTML = "";
      return;
    }

    ensureLineup(currentTournamentKey);
    const L = lineups[currentTournamentKey];

    const rows = [];

    rows.push({
      title: "Gardien",
      key: "G",
      slots: [{ group:"G", role:"G" }]
    });

    rows.push({
      title: "Défense",
      key: "D",
      slots: [
        { group:"D1", role:"LD" },
        { group:"D1", role:"RD" },
        { group:"D2", role:"LD" },
        { group:"D2", role:"RD" },
        { group:"D3", role:"LD" },
        { group:"D3", role:"RD" }
      ]
    });

    rows.push({
      title: "Attaque",
      key: "F",
      slots: [
        { group:"F1", role:"LW" },
        { group:"F1", role:"C"  },
        { group:"F1", role:"RW" },
        { group:"F2", role:"LW" },
        { group:"F2", role:"C"  },
        { group:"F2", role:"RW" },
        { group:"F3", role:"LW" },
        { group:"F3", role:"C"  },
        { group:"F3", role:"RW" }
      ]
    });

    rows.forEach(row => {
      const rowEl = document.createElement("div");
      rowEl.className = "lineup-row";

      const header = document.createElement("div");
      header.className = "lineup-row-header";
      const title = document.createElement("div");
      title.className = "lineup-row-title";
      title.textContent = row.title;
      const count = document.createElement("div");
      count.textContent = "";
      header.appendChild(title);
      header.appendChild(count);
      rowEl.appendChild(header);

      // group slots by group name
      const byGroup = {};
      row.slots.forEach(s => {
        if (!byGroup[s.group]) byGroup[s.group] = [];
        byGroup[s.group].push(s);
      });

      Object.keys(byGroup).forEach(g => {
        const line = document.createElement("div");
        line.className = "slot-row";
        byGroup[g].forEach(s => {
          const slotEl = document.createElement("div");
          slotEl.className = "slot";

          if (activeSlot &&
              activeSlot.tKey === currentTournamentKey &&
              activeSlot.group === s.group &&
              activeSlot.role === s.role){
            slotEl.classList.add("active");
          }

          slotEl.dataset.group = s.group;
          slotEl.dataset.role = s.role;
          slotEl.dataset.tkey = currentTournamentKey;

          const label = document.createElement("span");
          label.className = "slot-label-pill";
          label.textContent = s.group + " • " + s.role;

          const playerSpan = document.createElement("span");
          playerSpan.className = "slot-player";

          let assignedId = null;
          if (s.group === "G" && s.role === "G"){
            assignedId = L.G[0] || null;
          }else if (/^D[1-3]$/.test(s.group)){
            assignedId = L[s.group][s.role][0] || null;
          }else if (/^F[1-3]$/.test(s.group)){
            assignedId = L[s.group][s.role][0] || null;
          }

          if (assignedId){
            const p = allPlayers.find(x => x.id === assignedId);
            playerSpan.textContent = p ? p.name : assignedId;
          }else{
            playerSpan.classList.add("slot-empty");
            playerSpan.textContent = "Tap pour choisir";
          }

          const clearBtn = document.createElement("span");
          clearBtn.className = "slot-clear";
          clearBtn.textContent = assignedId ? "✕" : "";
          clearBtn.addEventListener("click", ev => {
            ev.stopPropagation();
            clearSlot(currentTournamentKey, s.group, s.role);
          });

          slotEl.appendChild(label);
          slotEl.appendChild(playerSpan);
          slotEl.appendChild(clearBtn);

          slotEl.addEventListener("click", () => {
            setActiveSlot(currentTournamentKey, s.group, s.role);
          });

          line.appendChild(slotEl);
        });
        rowEl.appendChild(line);
      });

      lineupBoardEl.appendChild(rowEl);
    });

    updateStatusBar();
  }

  function setActiveSlot(tKey, group, role){
    if (activeSlot &&
        activeSlot.tKey === tKey &&
        activeSlot.group === group &&
        activeSlot.role === role){
      // unselect if tapping same
      activeSlot = null;
    }else{
      activeSlot = { tKey, group, role };
    }
    renderLineup();
    renderPlayers();
  }

  function clearSlot(tKey, group, role){
    ensureLineup(tKey);
    const L = lineups[tKey];
    if (group === "G" && role === "G"){
      L.G = [];
    }else if (/^D[1-3]$/.test(group)){
      L[group][role] = [];
    }else if (/^F[1-3]$/.test(group)){
      L[group][role] = [];
    }
    renderLineup();
    renderSummary();
  }

  function assignPlayerToActiveSlot(playerId){
    if (!activeSlot) return;
    ensureLineup(activeSlot.tKey);
    const L = lineups[activeSlot.tKey];

    // Remove player from all slots of this tournoi
    const removeEverywhere = () => {
      L.G = L.G.filter(id => id !== playerId);
      ["D1","D2","D3"].forEach(g => {
        ["LD","RD"].forEach(r => {
          L[g][r] = L[g][r].filter(id => id !== playerId);
        });
      });
      ["F1","F2","F3"].forEach(g => {
        ["LW","C","RW"].forEach(r => {
          L[g][r] = L[g][r].filter(id => id !== playerId);
        });
      });
    };
    removeEverywhere();

    // Check eligibility
    const p = allPlayers.find(x => x.id === playerId);
    const sc = scoreForSlot(p, activeSlot.tKey, activeSlot.group, activeSlot.role);
    if (sc < 0){
      toast("Joueur non éligible à ce slot (position/dispo).");
      renderLineup();
      renderPlayers();
      return;
    }

    if (activeSlot.group === "G" && activeSlot.role === "G"){
      L.G = [playerId];
    }else if (/^D[1-3]$/.test(activeSlot.group)){
      L[activeSlot.group][activeSlot.role] = [playerId];
    }else if (/^F[1-3]$/.test(activeSlot.group)){
      L[activeSlot.group][activeSlot.role] = [playerId];
    }
    renderLineup();
    renderPlayers();
    renderSummary();
  }

  function updateStatusBar(){
    statusBarEl.innerHTML = "";
    if (!currentTournamentKey){
      return;
    }
    ensureLineup(currentTournamentKey);
    const L = lineups[currentTournamentKey];

    const cnt = {
      G: L.G.length,
      D:
        L.D1.LD.length + L.D1.RD.length +
        L.D2.LD.length + L.D2.RD.length +
        L.D3.LD.length + L.D3.RD.length,
      F:
        L.F1.LW.length + L.F1.C.length + L.F1.RW.length +
        L.F2.LW.length + L.F2.C.length + L.F2.RW.length +
        L.F3.LW.length + L.F3.C.length + L.F3.RW.length
    };

    const ok = (cnt.G === 1 && cnt.D === 6 && cnt.F === 9);

    const pill = document.createElement("span");
    pill.className = "status-pill " + (ok ? "ok" : "bad");
    pill.textContent = ok
      ? "Lineup complet (1G / 6D / 9F)"
      : `Lineup incomplet (G:${cnt.G}/1, D:${cnt.D}/6, F:${cnt.F}/9)`;
    statusBarEl.appendChild(pill);

    const t = document.createElement("span");
    t.textContent = ` Année ${currentYear} • ${TOURNAMENTS[currentTournamentKey].label}`;
    statusBarEl.appendChild(t);
  }

  btnCheckLineup.addEventListener("click", () => {
    updateStatusBar();
    toast("Lineup vérifié.");
  });

  // ========== SUMMARY ==========
  const summaryEl = document.getElementById("summary");

  function getSummaryData(){
    const tKey = currentTournamentKey;
    const year = currentYear;
    if (!tKey) return {text:"Pas de tournoi sélectionné.", data:null};

    ensureLineup(tKey);

    const L = lineups[tKey];
    const confMap = confirmed[tKey] || {};
    const confirmedIds = Object.keys(confMap);

    const cnt = {
      G: L.G.length,
      D:
        L.D1.LD.length + L.D1.RD.length +
        L.D2.LD.length + L.D2.RD.length +
        L.D3.LD.length + L.D3.RD.length,
      F:
        L.F1.LW.length + L.F1.C.length + L.F1.RW.length +
        L.F2.LW.length + L.F2.C.length + L.F2.RW.length +
        L.F3.LW.length + L.F3.C.length + L.F3.RW.length
    };

    return {
      text: "",
      data: {
        year,
        tournament: tKey,
        tournament_label: TOURNAMENTS[tKey].label,
        lineup_counts: cnt,
        confirmed_ids: confirmedIds
      }
    };
  }

  function renderSummary(){
    const {data} = getSummaryData();
    if (!data){
      summaryEl.textContent = "Sélectionne une année et un tournoi pour voir le résumé.";
      return;
    }
    const lines = [];

    lines.push(`Année: ${data.year}`);
    lines.push(`Tournoi: ${data.tournament_label}`);
    lines.push("");
    lines.push(`Lineup: G=${data.lineup_counts.G}, D=${data.lineup_counts.D}, F=${data.lineup_counts.F}`);
    lines.push(`Confirmés (${data.confirmed_ids.length}):`);
    if (data.confirmed_ids.length){
      data.confirmed_ids.forEach(id => {
        const p = allPlayers.find(x => x.id === id);
        lines.push(`  - ${p ? p.name : id}`);
      });
    }else{
      lines.push("  (aucun joueur marqué confirmé)");
    }

    summaryEl.textContent = lines.join("\n");
  }

  // ========== GitHub Integration ==========
  const ghTokenInput = document.getElementById("ghToken");
  const btnGhLoad = document.getElementById("btnGhLoad");
  const btnGhSave = document.getElementById("btnGhSave");

  function getGhToken(){
    if (ghToken) return ghToken;
    const v = (ghTokenInput.value || "").trim();
    if (!v){
      alert("Entre un GitHub PAT avec droits 'contents: read/write' sur le repo.");
      return null;
    }
    ghToken = v;
    return ghToken;
  }

  function lineupsPathForYear(year){
    return GH_LINEUPS_TEMPLATE.replace("YEAR", String(year));
  }

  btnGhLoad.addEventListener("click", async () => {
    const token = getGhToken();
    if (!token) return;

    const path = lineupsPathForYear(currentYear);

    try{
      const res = await fetch(
        `https://api.github.com/repos/${GH_OWNER}/${GH_REPO}/contents/${encodeURIComponent(path)}`,
        {
          headers:{
            "Accept":"application/vnd.github+json",
            "Authorization":`Bearer ${token}`,
            "X-GitHub-Api-Version":"2022-11-28"
          },
          cache:"no-store"
        }
      );

      if (res.status === 404){
        toast("Pas encore de lineups pour cette année (fichier manquant).");
        lineups = {};
        confirmed = {};
        ghLineupsSha = null;
        renderLineup();
        renderSummary();
        return;
      }

      if (!res.ok){
        const txt = await res.text();
        console.error("GitHub load error", res.status, txt);
        alert("Erreur GitHub (load). Vérifie le PAT / repo.");
        return;
      }

      const j = await res.json();
      ghLineupsSha = j.sha || null;
      const decoded = atob((j.content || "").replace(/\n/g,""));
      const data = JSON.parse(decoded);

      lineups   = clone(data.tournaments || {});
      confirmed = clone(data.confirmed   || {});

      toast("Lineups chargés depuis GitHub.");
      renderLineup();
      renderPlayers();
      renderSummary();
    }catch(e){
      console.error(e);
      alert("Erreur lors du chargement GitHub. Voir console.");
    }
  });

  btnGhSave.addEventListener("click", async () => {
    const token = getGhToken();
    if (!token) return;

    const path = lineupsPathForYear(currentYear);

    const payload = {
      version: 1,
      year: String(currentYear),
      updated_at: new Date().toISOString(),
      tournaments: lineups,
      confirmed: confirmed
    };

    const content = btoa(unescape(encodeURIComponent(JSON.stringify(payload, null, 2))));
    const body = {
      message: `chore: update lineups_${currentYear}.json via QHC admin`,
      content,
      sha: ghLineupsSha || undefined
    };

    try{
      const res = await fetch(
        `https://api.github.com/repos/${GH_OWNER}/${GH_REPO}/contents/${encodeURIComponent(path)}`,
        {
          method:"PUT",
          headers:{
            "Accept":"application/vnd.github+json",
            "Authorization":`Bearer ${token}`,
            "X-GitHub-Api-Version":"2022-11-28",
            "Content-Type":"application/json"
          },
          body:JSON.stringify(body)
        }
      );
      const j = await res.json();
      if (!res.ok){
        console.error("GitHub save error", res.status, j);
        alert("Erreur GitHub (save). Vérifie le PAT / repo.");
        return;
      }
      ghLineupsSha = j.content && j.content.sha ? j.content.sha : ghLineupsSha;
      toast("Lineups sauvegardés sur GitHub.");
    }catch(e){
      console.error(e);
      alert("Erreur lors de la sauvegarde GitHub. Voir console.");
    }
  });

  // ========== INIT ==========
  setupYearAndTournaments();
  renderPlayers();
  renderLineup();
  renderSummary();
</script>
</body>
</html>
