<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>QHC ‚Äî Admin ‚ÄúThe Road to The Throne‚Äù</title>
<meta name="description" content="QHC Admin ‚Ä¢ Composer les lineups (1G + 3x2 DEF + 3x3 AV) ‚Ä¢ Import .msg/.eml/.csv/.json ‚Ä¢ Chargement direct /data/players.json ‚Ä¢ Export/Import JSON ‚Äî 100% client-side" />
<link rel="icon" href="logos/gear.png" />

<!-- Open Graph / Twitter (aper√ßu avec engrenage) -->
<meta property="og:type" content="website" />
<meta property="og:url" content="https://yaban1981.github.io/the-road-to-the-throne-site/admin-rttt-48a1.html" />
<meta property="og:title" content="QHC Admin ‚Äî The Road to The Throne" />
<meta property="og:description" content="Interface coach (sans DB) pour composer les lineups QHC. Drag & drop d‚Äôemails .msg/.eml, import CSV/JSON, export/import de lineups." />
<meta property="og:image" content="https://yaban1981.github.io/the-road-to-the-throne-site/logos/gear.png" />
<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:title" content="QHC Admin ‚Äî The Road to The Throne" />
<meta name="twitter:description" content="Composez vos lineups QHC et exportez en JSON (sans base de donn√©es)." />
<meta name="twitter:image" content="https://yaban1981.github.io/the-road-to-the-throne-site/logos/gear.png" />

<!-- msgreader pour .msg Outlook -->
<script src="https://cdn.jsdelivr.net/npm/msgreader@1.0.8/dist/msgreader.min.js"></script>

<style>
:root{
  --bg:#0f172a; --panel:#0e152a; --panel2:#0a1020;
  --text:#e7ecf3; --muted:#a7b3c7;
  --gold:#d4af37; --blue:#3b82f6; --goldTint:rgba(212,175,94,.10); --goldStroke:rgba(212,175,94,.35);
  --ring:rgba(59,130,246,.30); --r:16px;
}
*{box-sizing:border-box; -webkit-tap-highlight-color:transparent}
html,body{scroll-behavior:smooth; -webkit-text-size-adjust:100%}
body{
  margin:0; font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Helvetica,Arial,sans-serif;
  background: radial-gradient(900px 500px at 10% -10%, #0b2451 0%, transparent 60%), linear-gradient(180deg,#0a1020,#0b1222);
  color:var(--text); line-height:1.5;
}

/* Header */
header{display:flex; align-items:center; gap:18px; padding:24px 16px; border-bottom:1px solid rgba(255,255,255,.08)}
header .logo{width:120px; height:120px; border-radius:22px; overflow:hidden; display:grid; place-items:center; background:#0b1020; box-shadow:0 14px 40px rgba(0,0,0,.35)}
@media(min-width:1000px){ header .logo{width:160px; height:160px} }
header .logo img{width:100%; height:100%; object-fit:cover}
header .text{display:flex; flex-direction:column}
header h1{margin:0; font-size:2rem}
@media(min-width:1000px){ header h1{font-size:2.4rem} }
header .sub{color:#dfe7ff; font-size:1.1rem}
header .meta{color:#9fb7ff; font-size:.95rem}

/* Cards & layout */
main{max-width:1200px; margin:0 auto; padding:16px}
.card{background:linear-gradient(180deg, var(--panel2), var(--panel)); border:1px solid rgba(255,255,255,.08); border-radius:var(--r); padding:18px; margin:14px 0; box-shadow:0 10px 28px rgba(0,0,0,.35)}
h2{margin:0 0 12px; font-size:1.25rem}
.bar{display:flex; gap:10px; flex-wrap:wrap; align-items:center}
label{display:block; margin:8px 0 6px; color:#dfe7ff}

input[type="text"],input[type="email"],input[type="tel"],input[type="range"],select,textarea{
  width:100%; padding:14px; border-radius:12px; border:1.5px solid rgba(255,255,255,.16);
  background:#0b1020; color:var(--text); outline:none; font-size:16px; transition:.2s
}
input:focus,select:focus,textarea:focus{border-color:var(--blue); box-shadow:0 0 0 3px var(--ring); background:#0b142a}
input.valid,select.valid,textarea.valid{border-color:var(--gold); background:rgba(212,175,94,.08)}
select{
  background-image: url("data:image/svg+xml,%3Csvg width='18' height='18' viewBox='0 0 24 24' fill='%23d4af37' xmlns='http://www.w3.org/2000/svg'%3E<path d='M7 10l5 5 5-5'/></svg>");
  background-repeat:no-repeat; background-position:right .8rem center; padding-right:2.2rem;
}
textarea{min-height:110px; resize:vertical}
.small{color:var(--muted); font-size:.9rem}
.btn{display:inline-flex; align-items:center; gap:8px; padding:12px 16px; border:none; border-radius:12px; font-weight:700; cursor:pointer}
.btn.primary{background:linear-gradient(135deg, var(--gold), var(--blue)); color:#fff; box-shadow:0 10px 24px rgba(59,130,246,.28)}
.btn.ghost{background:transparent; color:var(--text); border:1px solid rgba(255,255,255,.2)}

/* Table */
.tablewrap{max-height:360px; overflow:auto; border:1px solid rgba(255,255,255,.08); border-radius:12px}
table{width:100%; border-collapse:collapse; font-size:.95rem}
th,td{border-bottom:1px solid rgba(255,255,255,.08); padding:10px 8px; text-align:left; vertical-align:top}
th{color:#cfe2ff}
td.dr{cursor:grab}
.badge{display:inline-block; padding:4px 8px; border-radius:12px; font-size:.8rem; border:1px solid rgba(255,255,255,.15)}
.badge.DEF{background:#0b2230; border-color:#1b3a50}
.badge.FWD{background:#301d0b; border-color:#6b3b0f}
.badge.CEN{background:#2a2030; border-color:#5b3d6b}
.badge.GOL{background:#1a1f2b; border-color:#2e3b52}
.fit{white-space:nowrap}

tr.candidate-yes{ background: rgba(212,175,94,.10); }
tr.candidate-no { opacity:.35; }

/* Board: 3x2 DEF + 3x3 FWD + 1 G per team */
.board{ display:grid; grid-template-columns: repeat(3, 1fr); gap:16px }
.slotcol{ display:grid; gap:10px }
.slot.head{ font-weight:700; color:#e7ecf3; background:transparent; border:none; min-height:auto; padding:0 }
.slot{
  position:relative; background:#0b1020; border:2px dashed rgba(255,255,255,.18);
  border-radius:12px; min-height:60px; padding:10px 44px 10px 10px; transition:.2s;
}
.slot .slot-label{ position:absolute; right:12px; top:8px; font-size:.8rem; color:#d4d4d4 }
.slot.active{ box-shadow:0 0 0 3px var(--gold); border-color: var(--gold) }
.slot.drop-ok{ border-color: var(--blue) }
.chip{ display:inline-flex; align-items:center; gap:8px; padding:8px 10px; background:#0b1020; border:1px solid rgba(255,255,255,.16); border-radius:999px; margin:4px; position:relative }
.chip .role{ font-weight:800; font-size:.8rem; color:#eaeaea; padding:2px 6px; border-radius:8px; border:1px solid rgba(255,255,255,.1) }
.chip .pos{ font-weight:800; font-size:.75rem; padding:2px 6px; border-radius:8px; background: var(--gold); color:#0b1020 }
.chip .x{ cursor:pointer; color:#cbd5e1 }

/* Slider (si jamais on en ajoute) */
.slider-wrap{ position:relative; margin:30px 0 16px; background:rgba(11,16,32,.5); border:2px solid rgba(212,175,94,.35); border-radius:12px; padding:14px }
.hand-hint{ position:absolute; top:-36px; left:0; z-index:5; animation: handmove 3s ease-in-out infinite; opacity:.95; pointer-events:none }
.hand-hint svg{ width:36px; height:36px; color: var(--gold); filter: drop-shadow(0 2px 4px rgba(0,0,0,.35)) }
@keyframes handmove{ 0%{transform:translateX(0); opacity:0} 15%{opacity:1} 40%{transform:translateX(calc(100% - 60px))} 60%{transform:translateX(calc(100% - 60px))} 85%{transform:translateX(0)} 100%{opacity:0} }

/* Preview (collaps√©) */
.preview{ max-height:180px; overflow:hidden; position:relative; background:#0b1020; border:1px solid rgba(255,255,255,.08); border-radius:12px; padding:12px }
.preview.expanded{ max-height:none }
.preview .fade{ position:absolute; left:0; right:0; bottom:0; height:48px; background: linear-gradient(180deg, transparent, rgba(0,0,0,.85)) }
.showmore{ margin-top:10px }
.showmore .btn{ padding:10px 14px }
</style>
</head>
<body>
<header>
  <div class="logo"><img src="logos/qhc.png" alt="Logo Qu√©bec HC"></div>
  <div class="text">
    <h1>QHC ‚Äî Admin ‚ÄúThe Road to The Throne‚Äù</h1>
    <div class="sub">Interface coach ‚Ä¢ 1 Goaler ‚Ä¢ 3√ó2 DEF ‚Ä¢ 3√ó3 AV ‚Ä¢ Drag & Drop</div>
    <div class="meta">Confiance ‚â• 80% ‚Ä¢ Filtres (poste/c√¥t√©/dispo) ‚Ä¢ Import .msg/.eml/.csv ‚Ä¢ Export/Import JSON</div>
  </div>
</header>

<main>
  <!-- Import -->
  <section class="card">
    <h2>1) Importer des joueurs</h2>
    <div class="bar">
      <button class="btn primary" id="btnFetch">Charger depuis <code>/data/players.json</code></button>
      <span class="small">ou</span>
      <input type="file" id="filePlayers" accept=".json,.csv,.eml,.msg,text/*,application/json,.txt,.msg" />
      <span class="small">ou collez des emails FormSubmit :</span>
    </div>
    <textarea id="taEmails" placeholder="Collez ici 1..N emails (format 'Name  Value' par ligne)‚Ä¶"></textarea>
    <div class="bar">
      <button class="btn primary" id="btnParse">‚ûï Parser & ajouter</button>
      <button class="btn ghost" id="btnClear">Effacer</button>
    </div>
    <div id="dropZone" style="border:2px dashed rgba(255,255,255,.2);border-radius:12px;padding:18px;text-align:center;margin-top:12px">
      Glissez-d√©posez ici vos fichiers **.msg / .eml / .csv / .json / .txt** (ou collez du texte ci-dessus)
    </div>
  </section>

  <!-- Players -->
  <section class="card">
    <h2>2) Joueurs</h2>
    <div class="bar">
      <input id="q" type="text" placeholder="Recherche (nom/ville)‚Ä¶" style="max-width:260px">
      <select id="fPos"><option value="">Position (toutes)</option><option>DEF</option><option>FWD</option><option>CEN</option><option>GOL</option></select>
      <select id="fAvail"><option value="">Tournoi (Yes)</option><option value="boston">Boston</option><option value="meltdown">Meltdown</option><option value="throne">Throne</option></select>
      <select id="fConf"><option value="">Confiance</option><option value="80">‚â• 80%</option><option value="90">‚â• 90%</option></select>
      <span class="small" id="hintTarget"></span>
      <button class="btn ghost" id="btnToggle">Afficher tout / Candidats</button>
    </div>
    <div class="tablewrap">
      <table id="tbl">
        <thead>
          <tr>
            <th>Nom</th><th>Ann√©e</th><th>Ville</th><th>Postes</th><th>Side</th>
            <th>BOS</th><th>MTL</th><th>THR</th><th>Conf</th><th>Drag</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
    <div class="small">Astuce : fais glisser une ligne (col. ‚ÄúDrag‚Äù) vers un slot plus bas (LD1/LW1/‚Ä¶/G)</div>
  </section>

  <!-- Boards pour 3 tournois -->
  <section class="card">
    <h2>3) Lineups par tournoi (1G ‚Ä¢ 3√ó2 DEF ‚Ä¢ 3√ó3 AV)</h2>
    <div id="boards"></div>
    <div class="bar" style="margin-top:16px">
      <button class="btn primary" id="btnAuto">‚ú® Auto-suggest (poste + c√¥t√© + dispo + confiance)</button>
      <button class="btn ghost" id="btnCheck">‚úî V√©rifier quotas</button>
      <span id="status" class="small"></span>
    </div>
  </section>

  <!-- Export / Import lineups & preview -->
  <section class="card">
    <h2>4) Export / Import</h2>
    <div class="bar">
      <button class="btn" id="btnExportPlayers">üíæ Exporter <code>players.json</code></button>
      <button class="btn" id="btnExportLineups">üíæ Exporter <code>lineups.json</code></button>
      <span class="small">Importer un <code>lineups.json</code> :</span>
      <input type="file" id="fileLineup" accept=".json,application/json" />
    </div>
    <div class="preview" id="pvWrap">
      <pre id="pvShort" style="white-space:pre-wrap"></pre>
      <div class="fade"></div>
    </div>
    <div class="showmore"><button class="btn ghost" id="btnExpand">Afficher/masquer l‚Äôaper√ßu complet</button></div>
  </section>
</main>

<script>
/* ===================== STATE & HELPERS ===================== */
const POS_MAP={Defence:'DEF',Defense:'DEF',Def:'DEF',Forward:'FWD',Avant:'FWD',Center:'CEN',Centre:'CEN',Goaler:'GOL',Goalie:'GOL',Gardien:'GOL'};
const TEAMS = {
  boston : { label:'Boston',   key:'boston',   date:[2026,5,29] },
  meltdown:{ label:'Montreal Meltdown', key:'meltdown', date:[2026,6,5] },
  throne : { label:'The Throne', key:'throne', date:[2026,7,24] }
};
let state = {
  players: [],
  lineups: {
    boston:   { G:[], D1:{LD:[],RD:[]}, D2:{LD:[],RD:[]}, D3:{LD:[],RD:[]}, F1:{LW:[],C:[],RW:[]}, F2:{LW:[],C:[],RW:[]}, F3:{LW:[],C:[],RW:[]} },
    meltdown: { G:[], D1:{LD:[],RD:[]}, D2:{LD:[],RD:[]}, D3:{LD:[],RD:[]}, F1:{LW:[],C:[],RW:[]}, F2:{LW:[],C:[],RW:[]}, F3:{LW:[],C:[],RW:[]} },
    throne:   { G:[], D1:{LD:[],RD:[]}, D2:{LD:[],RD:[]}, D3:{LD:[],RD:[]}, F1:{LW:[],C:[],RW:[]}, F2:{LW:[],C:[],RW:[]}, F3:{LW:[],C:[],RW:[]} }
  }
};
const $=s=>document.querySelector(s), $$=s=>document.querySelectorAll(s);
const slug=s=>(s||'').toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g,'').replace(/[^a-z0-9]+/g,'-').replace(/^-+|-+$/g,'');

/* ===================== IMPORT / NORMALIZE ===================== */
function parseEmailBlocks(txt){
  const blocks = txt.trim().split(/\n\s*\n/);
  const out=[];
  for(const block of blocks){
    const lines=block.split(/\r?\n/);
    const o={};
    for(const line of lines){
      const m=line.match(/^([A-Za-z0-9_ ]+)\s+(.+)$/);
      if(!m) continue;
      o[m[1].trim().toLowerCase().replace(/\s+/g,'_')] = m[2].trim();
    }
    const p = normalizeRow(o, block);
    if (p && p.name) out.push(p);
  }
  return out;
}
function normalizeRow(raw, rawTxt){
  const name=raw.player_name||raw.name||''; const by=raw.birth_year?Number(raw.birth_year):null; const id=`${slug(name)}-${by??'xxxx'}`;
  const sides=[]; if((raw.side_right||'').toUpperCase()==='YES') sides.push('R'); if((raw.side_left||'').toUpperCase()==='YES') sides.push('L');
  const P = (raw.primary_position && (POS_MAP[raw.primary_position]||raw.primary_position.toUpperCase())) || '';
  const S = (raw.secondary_position && (POS_MAP[raw.secondary_position]||raw.secondary_position.toUpperCase())) || 'NONE';
  const yn=v=>{const s=(v||'').toUpperCase(); if(s==='YES'||s==='OUI') return 'Yes'; if(s==='NO'||s==='NON') return 'No'; return 'TBD';};
  const tsMatch = /Submitted\s+at\s+(.+?)\s*\(/i.exec(rawTxt||'');
  const submitted_at = tsMatch ? new Date(tsMatch[1]+' UTC').toISOString() : null;
  const srcMatch = /(https?:\/\/\S+)/.exec(rawTxt||'');
  return {
    id, name,
    birth_year: isNaN(by)?null:by,
    city: raw.city||'',
    current_team: raw.current_team||'',
    parent:{email:raw.parent_email||'', phone:raw.parent_phone||''},
    positions:{primary:P, secondary:S},
    sides,
    jersey:{type:raw.jersey_type||'', size:raw.jersey_size||'', pref_numbers:[raw.jersey_number_1,raw.jersey_number_2,raw.jersey_number_3].filter(Boolean)},
    availability:{boston:yn(raw.boston_showdown), meltdown:yn(raw.montreal_meltdown), throne:yn(raw.the_throne)},
    confidence_pct: parseInt(raw.confidence_pct||'0',10)||0,
    consents:{
      throne_rule:(raw.ack_throne_rule||'').toLowerCase()==='on' || (raw.ack_throne_rule||'').toLowerCase()==='true',
      limited_spots:(raw.ack_limited_spots||raw.awk_limited_spots||'').toLowerCase()==='on' || (raw.ack_limited_spots||'').toLowerCase()==='true',
      consent_contact:(raw.consent_contact||'').toLowerCase()==='on' || (raw.consent_contact||'').toLowerCase()==='true'
    },
    submitted_at, source: srcMatch?srcMatch[1]:null
  };
}
function upsertPlayer(p){
  const i = state.players.findIndex(x=>x.id===p.id);
  if(i<0){ state.players.push(p); return; }
  const a=state.players[i].submitted_at, b=p.submitted_at;
  if(b && (!a || new Date(b)>new Date(a))) state.players[i]=p;
}

/* ===================== TABLE RENDER & FILTERS ===================== */
const tblBody = $('#tbl tbody');
let activeTarget = null;       // {team, role, group, el}
let showAll = false;

function matchScoreForRole(p, role, team){
  const av=(p.availability?.[team]||'').toUpperCase();
  if(av==='NO') return -999;
  let s=0;
  const has=(x)=> (p.positions?.primary===x || p.positions?.secondary===x);
  if(role==='G'){ if(has('GOL')) s+=6; else return -999; }
  if(role==='LD'||role==='RD'){
    if(!has('DEF')) return -999; s+=4;
    const need=(role==='LD')?'L':'R';
    if((p.sides||[]).includes(need)) s+=2;
  }
  if(role==='LW'||role==='RW'){
    if(has('FWD')) s+=3; else if(has('CEN')) s+=1;
    const need=(role==='LW')?'L':'R';
    if((p.sides||[]).includes(need)) s+=2;
  }
  if(role==='C'){
    if(has('CEN')) s+=4; else if(has('FWD')) s+=2;
  }
  if(av==='YES') s+=2;
  const c = Number(p.confidence_pct)||0;
  if(c>=90) s+=2; else if(c>=80) s+=1;
  return s;
}

function renderPlayers(){
  const q=($('#q').value||'').toLowerCase();
  const pos=$('#fPos').value; const av=$('#fAvail').value; const confMin=parseInt($('#fConf').value||'0',10);
  let list=[...state.players];
  if(q) list=list.filter(p=>(p.name||'').toLowerCase().includes(q)||(p.city||'').toLowerCase().includes(q));
  if(pos) list=list.filter(p=>p.positions?.primary===pos||p.positions?.secondary===pos);
  if(av) list=list.filter(p=>(p.availability?.[av]||'').toUpperCase()==='YES');
  if(confMin) list=list.filter(p=>(p.confidence_pct||0)>=confMin);

  // Candidate scoring if a slot is active
  let scored = list.map(p=>({p,score: activeTarget? matchScoreForRole(p, activeTarget.role, activeTarget.team) : 0}));
  if (activeTarget){
    // sort best first
    scored.sort((a,b)=> b.score-a.score || a.p.name.localeCompare(b.p.name));
  } else {
    scored.sort((a,b)=> a.p.name.localeCompare(b.p.name));
  }

  tblBody.innerHTML='';
  for(const {p,score} of scored){
    const tr=document.createElement('tr');
    if(activeTarget){
      if(score>=1) tr.classList.add('candidate-yes'); else if(!showAll) tr.classList.add('candidate-no');
    }
    tr.innerHTML=`
      <td class="dr" draggable="true" data-id="${p.id}">${p.name}<div class="small">${p.parent?.email||''}</div></td>
      <td>${p.birth_year||''}</td>
      <td>${p.city||''}</td>
      <td><span class="badge ${p.positions?.primary||''}">${p.positions?.primary||''}</span> ${p.positions?.secondary && p.positions.secondary!=='NONE'?`<span class="badge ${p.positions.secondary}">${p.positions.secondary}</span>`:''}</td>
      <td class="fit">${(p.sides||[]).join('/')||'-'}</td>
      <td class="fit">${p.availability?.boston||''}</td>
      <td class="fit">${p.availability?.meltdown||''}</td>
      <td class="fit">${p.availability?.throne||''}</td>
      <td class="fit">${p.confidence_pct!=null?p.confidence_pct+'%':''}</td>
      <td class="fit small muted">Drag</td>
    `;
    tblBody.appendChild(tr);
  }
  // drag sources
  tblBody.querySelectorAll('td.dr').forEach(td=>{
    td.addEventListener('dragstart',e=>{
      e.dataTransfer.setData('text/plain', td.dataset.id);
      td.parentElement.style.opacity='.6';
    });
    td.addEventListener('dragend',()=>{ td.parentElement.style.opacity=''; });
  });

  updatePreviewShort();
}

/* ===================== BOARDS (3 tournois) ===================== */
function buildBoards(){
  const holder = document.getElementById('boards');
  holder.innerHTML='';
  for (const key of Object.keys(TEAMS)){
    const wrap = document.createElement('div'); wrap.className='card';
    wrap.innerHTML = `<h3 style="margin:0 0 8px">${TEAMS[key].label}</h3>`;
    const board = document.createElement('div'); board.className='board';

    // DEF
    const colD=document.createElement('div'); colD.className='slotcol';
    colD.appendChild(headSlot('D√©fense'));
    ['D1','D2','D3'].forEach(g=>{
      colD.appendChild(slotEl(`${key}-LD${g.substring(1)}`, key,'LD',g));
      colD.appendChild(slotEl(`${key}-RD${g.substring(1)}`, key,'RD',g));
    });

    // FWD
    const colF=document.createElement('div'); colF.className='slotcol';
    colF.appendChild(headSlot('Attaquants'));
    ['F1','F2','F3'].forEach(g=>{
      const row=document.createElement('div'); row.style.display='flex'; row.style.gap='10px';
      row.appendChild(slotEl(`${key}-LW${g.substring(1)}`, key,'LW',g));
      row.appendChild(slotEl(`${key}-C${g.substring(1)}`, key,'C',g));
      row.appendChild(slotEl(`${key}-RW${g.substring(1)}`, key,'RW',g));
      colF.appendChild(row);
    });

    // G
    const colG=document.createElement('div'); colG.className='slotcol';
    colG.appendChild(headSlot('Goaler'));
    colG.appendChild(slotEl(`${key}-G`, key,'G','G'));

    board.appendChild(colD); board.appendChild(colF); board.appendChild(colG);
    wrap.appendChild(board);
    holder.appendChild(wrap);
  }
  renderBoards();
}
function headSlot(text){ const d=document.createElement('div'); d.className='slot head'; d.textContent=text; return d; }
function slotEl(id, team, role, group){
  const s=document.createElement('div'); s.className='slot'; s.id=id;
  s.dataset.team=team; s.dataset.role=role; s.dataset.group=group;
  const lab=document.createElement('div'); lab.className='slot-label'; lab.textContent = `${role}${group==='G'?'':group.substring(1)}`;
  s.appendChild(lab);
  s.addEventListener('dragover', e=>{ e.preventDefault(); s.classList.add('drop-ok'); setActiveTarget(s); });
  s.addEventListener('dragleave', ()=> s.classList.remove('drop-ok'));
  s.addEventListener('drop', e=>{
    e.preventDefault(); s.classList.remove('drop-ok'); clearActiveTarget();
    const id=e.dataTransfer.getData('text/plain'); addToSlot(team, role, group, id);
  });
  s.addEventListener('click', ()=> setActiveTarget(s));
  return s;
}
function renderBoards(){
  for (const [team, layout] of Object.entries(state.lineups)){
    // Goaler
    renderSlotChips(document.getElementById(`${team}-G`), layout.G, team,'G','G');
    // DEF
    for (const g of ['D1','D2','D3']){
      renderSlotChips(document.getElementById(`${team}-LD${g.substring(1)}`), layout[g].LD, team,'LD',g);
      renderSlotChips(document.getElementById(`${team}-RD${g.substring(1)}`), layout[g].RD, team,'RD',g);
    }
    // FWD
    for (const g of ['F1','F2','F3']){
      renderSlotChips(document.getElementById(`${team}-LW${g.substring(1)}`), layout[g].LW, team,'LW',g);
      renderSlotChips(document.getElementById(`${team}-C${g.substring(1)}`),  layout[g].C,  team,'C', g);
      renderSlotChips(document.getElementById(`${team}-RW${g.substring(1)}`), layout[g].RW, team,'RW',g);
    }
  }
}
function renderSlotChips(slotEl, arr, team, role, group){
  if(!slotEl) return;
  slotEl.innerHTML = `<div class="slot-label">${role}${group==='G'?'':group.substring(1)}</div>`;
  (arr||[]).forEach(id=>{
    const p = state.players.find(x=>x.id===id);
    const chip=document.createElement('span'); chip.className='chip';
    const pos=p?.positions?.primary||'';
    chip.innerHTML = `<span class="role">${p?.name||id}</span><span class="badge ${pos}">${pos}</span><span class="x" title="Retirer">‚úï</span>`;
    chip.querySelector('.x').onclick=()=> removeFromSlot(team, role, group, id);
    slotEl.appendChild(chip);
  });
}
function addToSlot(team, role, group, id){
  const L = state.lineups[team]; if(!L) return;
  // emp√™cher doublons dans le m√™me team
  for(const g of ['D1','D2','D3','F1','F2','F3']){
    ['LD','RD','LW','C','RW'].forEach(r=>{
      const arr=L[g]?.[r]; if(arr){ const i=arr.indexOf(id); if(i>=0) arr.splice(i,1); }
    });
  }
  const all = [L.G, L.D1.LD, L.D1.RD, L.D2.LD, L.D2.RD, L.D3.LD, L.D3.RD, L.F1.LW, L.F1.C, L.F1.RW, L.F2.LW, L.F2.C, L.F2.RW, L.F3.LW, L.F3.C, L.F3.RW];
  const inG = L.G.indexOf(id)>=0;
  if(inG) L.G=[];
  if(role==='G'){ L.G=[id]; renderBoards(); return; }
  // DEF/FWD slots: un joueur max par slot
  const targetArr = (role==='LD'||role==='RD') ? L[group][role] : L[group][role];
  targetArr[0]=id;
  renderBoards();
}
function removeFromSlot(team, role, group, id){
  const L = state.lineups[team]; if(!L) return;
  if(role==='G'){ L.G=[]; renderBoards(); return; }
  const arr = L[group][role]; const i=arr.indexOf(id); if(i>=0) arr.splice(i,1);
  renderBoards();
}

function setActiveTarget(slotEl){
  clearActiveTarget();
  activeTarget = { team:slotEl.dataset.team, role:slotEl.dataset.role, group:slotEl.dataset.group, el:slotEl };
  slotEl.classList.add('active');
  $('#hintTarget').textContent = `Cible: ${activeTarget.team.toUpperCase()} ${activeTarget.role}${activeTarget.group==='G'?'':activeTarget.group.substring(1)} ‚Äî candidats surlign√©s`;
  renderPlayers();
}
function clearActiveTarget(){
  if(activeTarget?.el) activeTarget.el.classList.remove('active');
  activeTarget=null; $('#hintTarget').textContent=''; renderPlayers();
}

/* ===================== ACTIONS (filter/auto/check/export) ===================== */
$('#btnToggle').onclick=()=>{ showAll=!showAll; $('#btnToggle').textContent = showAll?'Masquer non pertinents':'Afficher tout / Candidats'; renderPlayers(); };

['q','fPos','fAvail','fConf'].forEach(id=> $( '#'+id ).addEventListener('input', renderPlayers));

$('#btnAuto').onclick=()=>{
  // pour chaque team, remplir G, D1..D3, F1..F3
  for(const t of Object.keys(state.lineups)){
    // Goaler
    if(state.lineups[t].G.length===0){
      const g = bestFor(t,'G'); if(g) state.lineups[t].G=[g.id];
    }
    // DEF
    for(const grp of ['D1','D2','D3']){
      if(state.lineups[t][grp].LD.length===0){ const p=bestFor(t,'LD'); if(p) state.lineups[t][grp].LD=[p.id]; }
      if(state.lineups[t][grp].RD.length===0){ const p=bestFor(t,'RD'); if(p) state.lineups[t][grp].RD=[p.id]; }
    }
    // FWD
    for(const grp of ['F1','F2','F3']){
      if(state.lineups[t][grp].LW.length===0){ const p=bestFor(t,'LW'); if(p) state.lineups[t][grp].LW=[p.id]; }
      if(state.lineups[t][grp].C.length===0 ){ const p=bestFor(t,'C');  if(p) state.lineups[t][grp].C =[p.id]; }
      if(state.lineups[t][grp].RW.length===0){ const p=bestFor(t,'RW'); if(p) state.lineups[t][grp].RW=[p.id]; }
    }
  }
  renderBoards(); $('#status').textContent='Auto-suggest termin√© (poste/c√¥t√©/dispo/confiance).';
};
function bestFor(team, role){
  const placed = new Set();
  const L = state.lineups[team];
  // joueurs d√©j√† utilis√©s dans ce team
  [L.G, L.D1.LD, L.D1.RD, L.D2.LD, L.D2.RD, L.D3.LD, L.D3.RD, L.F1.LW, L.F1.C, L.F1.RW, L.F2.LW, L.F2.C, L.F2.RW, L.F3.LW, L.F3.C, L.F3.RW].forEach(a=>a.forEach(id=>placed.add(id)));
  const scored = state.players
    .filter(p=>!placed.has(p.id))
    .map(p=>({p,score:matchScoreForRole(p,role,team)}))
    .filter(x=>x.score>0)
    .sort((a,b)=> b.score-a.score);
  return scored[0]?.p || null;
}

$('#btnCheck').onclick=()=>{
  const msgs=[];
  for(const t of Object.keys(state.lineups)){
    const L=state.lineups[t];
    const cnt = {
      G: L.G.length,
      D: L.D1.LD.length+L.D1.RD.length+L.D2.LD.length+L.D2.RD.length+L.D3.LD.length+L.D3.RD.length,
      F: L.F1.LW.length+L.F1.C.length+L.F1.RW.length+L.F2.LW.length+L.F2.C.length+L.F2.RW.length+L.F3.LW.length+L.F3.C.length+L.F3.RW.length
    };
    const bad = (cnt.G!==1) || (cnt.D!==6) || (cnt.F!==9);
    msgs.push(`${t}: ${bad?'‚ö†':'‚úî'} G:${cnt.G}/1, D:${cnt.D}/6, F:${cnt.F}/9`);
  }
  $('#status').textContent = msgs.join(' | ');
};

/* ===================== EXPORT / IMPORT JSON ===================== */
function toLineupsJson(){
  const t = {};
  for(const k of Object.keys(state.lineups)){
    const L=state.lineups[k];
    t[k]={ G: L.G, D1:L.D1, D2:L.D2, D3:L.D3, F1:L.F1, F2:L.F2, F3:L.F3, notes: L.notes||"" };
  }
  return { version:1, updated_at:new Date().toISOString(), tournaments:t };
}
$('#btnExportPlayers').onclick=()=> download('players.json', JSON.stringify({players:state.players},null,2));
$('#btnExportLineups').onclick=()=> download('lineups.json', JSON.stringify(toLineupsJson(),null,2));
$('#fileLineup').onchange=async e=>{
  const f=e.target.files[0]; if(!f) return;
  try{
    const txt=await f.text();
    const j=JSON.parse(txt);
    if(j.tournaments){
      // notre format ‚Äúpar slots‚Äù
      for(const k of Object.keys(state.lineups)){
        const T=j.tournaments[k]||{};
        if(T.G) state.lineups[k].G = T.G;
        ['D1','D2','D3'].forEach(g=>{
          state.lineups[k][g].LD = T[g]?.LD || [];
          state.lineups[k][g].RD = T[g]?.RD || [];
        });
        ['F1','F2','F3'].forEach(g=>{
          state.lineups[k][g].LW = T[g]?.LW || [];
          state.lineups[k][g].C  = T[g]?.C  || [];
          state.lineups[k][g].RW = T[g]?.RW || [];
        });
      }
    }else if(j.boston || j.meltdown || j.throne){
      // ancien format (def/fwd/gol) ‚Üí on repack
      for(const k of Object.keys(state.lineups)){
        const T=j[k]||{def:[],fwd:[],gol:[]};
        const D=T.def||[]; const F=T.fwd||[]; const G=T.gol||[];
        state.lineups[k].G = G.slice(0,1);
        const defPairs=[[ 'D1','LD'],['D1','RD'],['D2','LD'],['D2','RD'],['D3','LD'],['D3','RD']];
        defPairs.forEach(([g,r],i)=>{ const id=D[i]; if(id) state.lineups[k][g][r]=[id]; });
        const fTrip=[[ 'F1','LW'],['F1','C'],['F1','RW'],['F2','LW'],['F2','C'],['F2','RW'],['F3','LW'],['F3','C'],['F3','RW']];
        fTrip.forEach(([g,r],i)=>{ const id=F[i]; if(id) state.lineups[k][g][r]=[id]; });
      }
    }else throw new Error('format inconnu');
    renderBoards(); updatePreviewShort(); $('#status').textContent='Lineup import√©.';
  }catch(err){ alert('lineups.json invalide.'); }
};

function download(name, text){
  const blob=new Blob([text],{type:'application/json'}); const url=URL.createObjectURL(blob);
  const a=document.createElement('a'); a.href=url; a.download=name; a.click(); setTimeout(()=>URL.revokeObjectURL(url),500);
}

/* ===================== PREVIEW JSON (r√©duit) ===================== */
function updatePreviewShort(){
  const sample = {players: (state.players.slice(0,3)), lineups: toLineupsJson().tournaments };
  $('#pvShort').textContent = JSON.stringify(sample, null, 2);
}
$('#btnExpand').onclick=()=>{
  $('#pvWrap').classList.toggle('expanded');
};

/* ===================== IMPORT SOURCES (fetch / file / paste / dnd) ===================== */
$('#btnFetch').onclick=async()=>{
  try{
    const r=await fetch('data/players.json',{cache:'no-store'}); const j=await r.json();
    const arr = Array.isArray(j.players) ? j.players : (Array.isArray(j) ? j : []);
    arr.forEach(upsertPlayer); renderPlayers(); renderBoards(); updatePreviewShort(); $('#status').textContent='Charg√© depuis /data/players.json';
  }catch(e){ alert('Impossible de charger /data/players.json'); }
};
$('#btnParse').onclick=()=>{
  const raw=$('#taEmails').value.trim(); if(!raw){ alert('Colle un ou plusieurs emails FormSubmit.'); return; }
  const list=parseEmailBlocks(raw); list.forEach(upsertPlayer);
  $('#taEmails').value=''; renderPlayers(); renderBoards(); updatePreviewShort(); $('#status').textContent=`Ajout: ${list.length} joueur(s)`;
};
$('#btnClear').onclick=()=> $('#taEmails').value='';

$('#filePlayers').onchange=async e=>{
  const f=e.target.files[0]; if(!f) return;
  const txt=await f.text(); const name=f.name.toLowerCase();
  if(name.endsWith('.json')){ try{ const j=JSON.parse(txt); const arr=Array.isArray(j.players)?j.players:(Array.isArray(j)?j:[]); arr.forEach(upsertPlayer); }catch{ alert('JSON invalide'); } }
  else if(name.endsWith('.csv')){ csvToPlayers(txt).forEach(upsertPlayer); }
  else if(name.endsWith('.eml')||name.endsWith('.txt')){ parseEmailBlocks(stripHtml(txt)).forEach(upsertPlayer); }
  else if(name.endsWith('.msg')){ await parseMsgFile(f); }
  renderPlayers(); renderBoards(); updatePreviewShort();
};

const dz = $('#dropZone');
['dragenter','dragover','dragleave','drop'].forEach(ev=> dz.addEventListener(ev, e=>{ e.preventDefault(); e.stopPropagation(); }, false));
dz.addEventListener('dragover', ()=> dz.style.borderColor='rgba(59,130,246,.6)');
dz.addEventListener('dragleave', ()=> dz.style.borderColor='rgba(255,255,255,.2)');
dz.addEventListener('drop', async e=>{
  dz.style.borderColor='rgba(255,255,255,.2)';
  const f=e.dataTransfer.files?.[0]; if(!f) return;
  const txt=await f.text(); const n=f.name.toLowerCase();
  if(n.endsWith('.json')){ try{ const j=JSON.parse(txt); const arr=Array.isArray(j.players)?j.players:(Array.isArray(j)?j:[]); arr.forEach(upsertPlayer);}catch{alert('JSON invalide');} }
  else if(n.endsWith('.csv')){ csvToPlayers(txt).forEach(upsertPlayer); }
  else if(n.endsWith('.eml')||n.endsWith('.txt')){ parseEmailBlocks(stripHtml(txt)).forEach(upsertPlayer); }
  else if(n.endsWith('.msg')){ await parseMsgFile(f); }
  renderPlayers(); renderBoards(); updatePreviewShort();
});

/* ---- helpers import ---- */
function stripHtml(s){ return s.replace(/<\/?[^>]+(>|$)/g,''); }
function csvToPlayers(csv){
  const rows=csv.split(/\r?\n/).filter(r=>r.trim().length>0);
  if(rows.length<2) return [];
  const head=rows.shift().split(',').map(h=>h.trim().toLowerCase());
  const blocks=[];
  for(const r of rows){
    const cells = r.split(',').map(x=>x.trim());
    const o={}; head.forEach((h,i)=> o[h]=cells[i]||'');
    // recompose "Name  Value" format quickly
    let block=''; for(const k of Object.keys(o)){ if(!k) continue; block += `${k}  ${o[k]}\n`; }
    blocks.push(block);
  }
  const all= parseEmailBlocks(blocks.join('\n\n')); return all;
}
async function parseMsgFile(file){
  // Read as ArrayBuffer then parse with MSGReader
  const buf = await file.arrayBuffer();
  const mr = new MSGReader(buf);
  const info = mr.getFileData();
  const body = (info?.body || info?.bodyHTML || '');
  const plain = stripHtml(body);
  parseEmailBlocks(plain).forEach(upsertPlayer);
}

/* ===================== DRAG FROM TABLE TO SLOTS ===================== */
function setActiveFromEl(el){ setActiveTarget(el); }
document.addEventListener('click', e=>{
  if(!e.target.closest('.slot')) clearActiveTarget();
});

/* ===================== BUILD & INIT ===================== */
buildBoards();
renderPlayers();
updatePreviewShort();

/* ===================== COUNTDOWN (option l√©ger dans l‚Äôadmin) ===================== */
(function(){
  function mk(y,m,d){ return new Date(y, m-1, d, 0,0,0,0)}
  const targets = {
    'cd-boston':   mk(...TEAMS.boston.date),
    'cd-meltdown': mk(...TEAMS.meltdown.date),
    'cd-throne':   mk(...TEAMS.throne.date)
  };
  function upd(){
    const today = new Date(); const t0 = new Date(today.getFullYear(), today.getMonth(), today.getDate());
    for(const id of Object.keys(targets)){
      const el = document.getElementById(id); if(!el) continue;
      const days = Math.ceil((targets[id]-t0)/86400000);
      el.textContent = (days>0)? `J-${days}` : (days===0? 'Jour J' : 'Termin√©');
    }
  }
  upd(); setInterval(upd, 3600_000);
})();
</script>
</body>
</html>
